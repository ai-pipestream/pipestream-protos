syntax = "proto3";

package ai.pipestream.design.v1;

import "ai/pipestream/config/v1/pipeline_config_models.proto";
import "ai/pipestream/data/v1/pipeline_core_types.proto";

option java_multiple_files = true;
option java_package = "ai.pipestream.design.v1";

// Design Mode Service - Frontend pipeline simulation
service DesignModev1Service {
  // Create design-time graph (not deployed)
  rpc CreateDesignGraph(CreateDesignGraphRequest) returns (CreateDesignGraphResponse);

  // Simulate pipeline execution in frontend
  rpc SimulatePipeline(SimulatePipelineRequest) returns (SimulatePipelineResponse);

  // Test individual node with sample data
  rpc TestNode(TestNodeRequest) returns (TestNodeResponse);

  // Validate graph before deployment
  rpc ValidateDesignGraph(ValidateDesignGraphRequest) returns (ValidateDesignGraphResponse);

  // Deploy graph from design to production
  rpc DeployGraph(DeployGraphRequest) returns (DeployGraphResponse);

  // Get design-time graphs for user
  rpc ListDesignGraphs(ListDesignGraphsRequest) returns (ListDesignGraphsResponse);
}

// Request to create a new design-time graph
message CreateDesignGraphRequest {
  // Cluster ID where this design graph will be created
  string cluster_id = 1;
  // Display name for the graph
  string graph_name = 2;
  // Description of the graph's purpose
  string description = 3;
  // User ID of the designer/owner
  string user_id = 4;
}

// Response from creating a design graph
message CreateDesignGraphResponse {
  // Whether the graph was created successfully
  bool success = 1;
  // Status or error message
  string message = 2;
  // The created design graph
  ai.pipestream.config.v1.PipelineGraph design_graph = 3;
}

// Request to simulate pipeline execution in frontend
message SimulatePipelineRequest {
  // Design graph ID to simulate
  string design_graph_id = 1;
  // Sample document to process through the pipeline
  ai.pipestream.data.v1.PipeDoc sample_document = 2;
  // Optional starting node ID (defaults to graph entry point)
  string starting_node_id = 3;
  // Whether to return results after each step (for step-by-step debugging)
  bool step_by_step = 4;
}

// Response from pipeline simulation
message SimulatePipelineResponse {
  // Whether the simulation completed successfully
  bool success = 1;
  // Status or error message
  string message = 2;
  // List of simulation steps (each node's execution)
  repeated SimulationStep steps = 3;
  // Final document after all processing
  ai.pipestream.data.v1.PipeDoc final_result = 4;
  // Overall simulation metrics
  SimulationMetrics metrics = 5;
}

// Single step in a pipeline simulation
message SimulationStep {
  // Node ID that processed this step
  string node_id = 1;
  // Display name of the node
  string node_name = 2;
  // Document state before this node's processing
  ai.pipestream.data.v1.PipeDoc input_document = 3;
  // Document state after this node's processing
  ai.pipestream.data.v1.PipeDoc output_document = 4;
  // Simulated processing time in milliseconds
  int64 simulated_processing_time_ms = 5;
  // Whether this step succeeded in simulation
  bool simulated_success = 6;
  // Error message if simulation failed
  string simulated_error_message = 7;
}

// Metrics from a pipeline simulation
message SimulationMetrics {
  // Total time for entire simulation in milliseconds
  int64 total_simulation_time_ms = 1;
  // Number of nodes that were processed
  int32 nodes_processed = 2;
  // Number of nodes that failed in simulation
  int32 nodes_failed = 3;
  // Overall success rate (0.0 to 1.0)
  double overall_success_rate = 4;
}

// Request to test an individual node with sample data
message TestNodeRequest {
  // Design graph ID containing the node
  string design_graph_id = 1;
  // Node ID to test
  string node_id = 2;
  // Test document to process through the node
  ai.pipestream.data.v1.PipeDoc test_document = 3;
}

// Response from testing a single node
message TestNodeResponse {
  // Whether the node test succeeded
  bool success = 1;
  // Status or error message
  string message = 2;
  // Result document after node processing
  ai.pipestream.data.v1.PipeDoc result_document = 3;
  // Simulated processing time in milliseconds
  int64 simulated_processing_time_ms = 4;
  // List of warnings generated during test
  repeated string warnings = 5;
}

// Request to validate a graph before deployment
message ValidateDesignGraphRequest {
  // Design graph ID to validate
  string design_graph_id = 1;
  // Whether to verify that all required modules are registered
  bool check_module_availability = 2;
  // Whether to verify Kafka topic naming conventions
  bool check_kafka_topics = 3;
}

// Response from graph validation
message ValidateDesignGraphResponse {
  // Whether the graph passes all validation checks
  bool is_valid = 1;
  // List of validation errors that must be fixed
  repeated DesignValidationError errors = 2;
  // List of validation warnings (non-blocking)
  repeated ValidationWarning warnings = 3;
  // Deployment readiness assessment
  DeploymentReadiness deployment_readiness = 4;
}

// Validation error that prevents deployment
message DesignValidationError {
  // Machine-readable error code
  string error_code = 1;
  // Human-readable error message
  string message = 2;
  // Optional: specific node with error
  string node_id = 3;
  // Optional: specific edge with error
  string edge_id = 4;
}

// Validation warning (non-blocking)
message ValidationWarning {
  // Machine-readable warning code
  string warning_code = 1;
  // Human-readable warning message
  string message = 2;
  // Optional: specific node with warning
  string node_id = 3;
}

// Assessment of whether graph is ready for deployment
message DeploymentReadiness {
  // Whether the graph is ready to be deployed
  bool ready_for_deployment = 1;
  // List of module IDs that are referenced but not registered
  repeated string missing_modules = 2;
  // List of Kafka topic naming conflicts
  repeated string topic_conflicts = 3;
  // List of required permissions for deployment
  repeated string required_permissions = 4;
}

// Request to deploy a design graph to production
message DeployGraphRequest {
  // Design graph ID to deploy
  string design_graph_id = 1;
  // Target cluster ID (may be different from design cluster)
  string target_cluster_id = 2;
  // Whether to just validate without actually deploying
  bool dry_run = 3;
}

// Response from deploying a graph
message DeployGraphResponse {
  // Whether deployment succeeded
  bool success = 1;
  // Status or error message
  string message = 2;
  // ID of the deployed production graph
  string production_graph_id = 3;
  // List of deployment steps that were executed
  repeated DeploymentStep deployment_steps = 4;
}

// Single step in the deployment process
message DeploymentStep {
  // Name of the deployment step
  string step_name = 1;
  // Whether this step succeeded
  bool success = 2;
  // Status or error message for this step
  string message = 3;
  // Duration of this step in milliseconds
  int64 duration_ms = 4;
}

// Request to list design graphs
message ListDesignGraphsRequest {
  // Optional: filter by user ID
  string user_id = 1;
  // Optional: filter by cluster ID
  string cluster_id = 2;
  // Number of results per page
  int32 page_size = 3;
  // Pagination token from previous response
  string page_token = 4;
}

// Response containing list of design graphs
message ListDesignGraphsResponse {
  // List of design graph summaries
  repeated DesignGraphSummary graphs = 1;
  // Token for next page (empty if last page)
  string next_page_token = 2;
}

// Summary information for a design graph
message DesignGraphSummary {
  // Unique graph identifier
  string graph_id = 1;
  // Display name of the graph
  string name = 2;
  // Description of the graph's purpose
  string description = 3;
  // User ID of the designer/owner
  string user_id = 4;
  // Cluster ID where this graph is defined
  string cluster_id = 5;
  // Number of nodes in the graph
  int32 node_count = 6;
  // Number of edges in the graph
  int32 edge_count = 7;
  // Whether the graph passes validation
  bool is_valid = 8;
  // Whether the graph is ready for deployment
  bool ready_for_deployment = 9;
  // Timestamp when graph was created (Unix epoch milliseconds)
  int64 created_at = 10;
  // Timestamp when graph was last modified (Unix epoch milliseconds)
  int64 modified_at = 11;
}
