syntax = "proto3";

package ai.pipestream.connector.intake.v1;

import "ai/pipestream/data/v1/pipeline_core_types.proto";
import "google/protobuf/timestamp.proto";

option java_package = "ai.pipestream.connector.intake.v1";
option java_multiple_files = true;

// ============================================
// CONNECTOR-INTAKE-SERVICE
// Handles authentication, account lookup, metadata enrichment
// Agnostic to connector type (filesystem, database, API, etc.)
// ============================================

// High-throughput document ingestion service for all connector types.
//
// This service provides the main entry point for document ingestion into the AI Pipestream platform.
// It handles authentication, account verification, metadata enrichment, and routing to the repository layer.
// Supports both structured PipeDoc uploads and raw blob uploads with automatic wrapping.
service ConnectorIntakeService {
  // 1. The "Power User" path: Client sends a full PipeDoc
  // Best for internal services, advanced connectors, or "Box.com" style integrations
  // where the client already knows the structure.
  rpc UploadPipeDoc(UploadPipeDocRequest) returns (UploadPipeDocResponse);

  // 2. The "Simple" path: Client sends raw bytes (Blob) + minimal metadata
  // Best for "I just have a file" scenarios. Intake constructs the PipeDoc wrapper.
  rpc UploadBlob(UploadBlobRequest) returns (UploadBlobResponse);

  // Register a new crawl session (Async/Background only)
  rpc StartCrawlSession(StartCrawlSessionRequest) returns (StartCrawlSessionResponse);

  // End a crawl session (for cleanup, orphan detection)
  rpc EndCrawlSession(EndCrawlSessionRequest) returns (EndCrawlSessionResponse);

  // Heartbeat to keep session alive
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
}

// ============================================
// ADMIN SERVICE
// Separate service for connector administration
// ============================================

// Administrative operations for connector lifecycle management.
//
// Handles registration, configuration updates, and metadata queries for connectors.
service ConnectorAdminService {
  // Register a new connector
  rpc RegisterConnector(RegisterConnectorRequest) returns (RegisterConnectorResponse);

  // Update connector configuration
  rpc UpdateConnector(UpdateConnectorRequest) returns (UpdateConnectorResponse);

  // Get connector details
  rpc GetConnector(GetConnectorRequest) returns (GetConnectorResponse);

  // Validate API key for a connector
  rpc ValidateApiKey(ValidateApiKeyRequest) returns (ValidateApiKeyResponse);

  // List all connectors for an account
  rpc ListConnectors(ListConnectorsRequest) returns (ListConnectorsResponse);

  // Enable/disable a connector
  rpc SetConnectorStatus(SetConnectorStatusRequest) returns (SetConnectorStatusResponse);

  // Delete a connector (soft delete)
  rpc DeleteConnector(DeleteConnectorRequest) returns (DeleteConnectorResponse);

  // Generate new API key for a connector
  rpc RotateApiKey(RotateApiKeyRequest) returns (RotateApiKeyResponse);

  // Get crawl history for a connector
  rpc GetCrawlHistory(GetCrawlHistoryRequest) returns (GetCrawlHistoryResponse);
}

// ============================================
// UPLOAD MESSAGES
// ============================================

// Request to upload a fully-formed PipeDoc.
//
// Power user path for internal services and advanced connectors.
message UploadPipeDocRequest {
  // Connector identifier.
  string connector_id = 1;
  // API key or JWT token for authentication.
  string api_key = 2;
  // Optional session ID for grouping related uploads.
  string session_id = 3;
  // The full document structure with all metadata and content.
  ai.pipestream.data.v1.PipeDoc pipe_doc = 4;
}

// Request to upload raw file content with minimal metadata.
//
// Simple path for basic file uploads where the service constructs the PipeDoc wrapper.
message UploadBlobRequest {
  // Connector identifier.
  string connector_id = 1;
  // API key for authentication.
  string api_key = 2;
  // Optional session ID for grouping related uploads.
  string session_id = 3;
  // Original filename.
  string filename = 4;
  // MIME type of the content.
  string mime_type = 5;
  // Virtual path in the connector's namespace (e.g., "/folder/file.txt").
  string path = 6;
  // Additional metadata key-value pairs.
  map<string, string> metadata = 7;
  // Raw file content (up to 2GB).
  bytes content = 8;
}

// Response from document upload operations.
message UploadPipeDocResponse {
  // Whether the upload succeeded.
  bool success = 1;
  // Document ID assigned by the repository service.
  string doc_id = 2;
  // Status or error message.
  string message = 3;
}

message UploadBlobResponse {
  // Whether the upload succeeded.
  bool success = 1;
  // Document ID assigned by the repository service.
  string doc_id = 2;
  // Status or error message.
  string message = 3;
}

// ============================================
// CONNECTOR CONFIG
// Simplified config returned after validation
// ============================================

// Connector configuration returned after authentication.
message ConnectorConfig {
  // Account owning this connector.
  string account_id = 1;
  // S3 bucket for document storage.
  string s3_bucket = 2;
  // Base path prefix in S3 for this connector.
  string s3_base_path = 3;
  // Maximum file size allowed in bytes.
  int64 max_file_size = 4;
  // Rate limit for uploads per minute.
  int64 rate_limit_per_minute = 5;
  // Default metadata applied to all documents.
  map<string, string> default_metadata = 6;
}

// ============================================
// CRAWL SESSION MANAGEMENT
// ============================================

// Request to start a new crawl session.
message StartCrawlSessionRequest {
  // Connector identifier.
  string connector_id = 1;
  // API key for authentication.
  string api_key = 2;
  // Client-provided crawl identifier.
  string crawl_id = 3;
  // Crawl metadata and parameters.
  CrawlMetadata metadata = 4;
  // Whether to track all documents in this crawl for orphan detection.
  bool track_documents = 5;
  // Whether to delete documents not seen in this crawl.
  bool delete_orphans = 6;
}

// Response from starting a crawl session.
message StartCrawlSessionResponse {
  // Whether session creation succeeded.
  bool success = 1;
  // Server-assigned session identifier.
  string session_id = 2;
  // Client-provided crawl identifier.
  string crawl_id = 3;
  // Status or error message.
  string message = 4;
}

// Request to end an active crawl session.
message EndCrawlSessionRequest {
  // Session identifier to end.
  string session_id = 1;
  // Crawl identifier.
  string crawl_id = 2;
  // Summary statistics for the completed crawl.
  CrawlSummary summary = 3;
}

// Metadata describing a crawl session.
message CrawlMetadata {
  // Type of connector (e.g., "filesystem", "confluence", "database").
  string connector_type = 1;
  // Connector version string.
  string connector_version = 2;
  // Timestamp when crawl started.
  google.protobuf.Timestamp crawl_started = 3;
  // Source system being crawled.
  string source_system = 4;
  // Crawl-specific parameters.
  map<string, string> parameters = 5;
}

// Summary statistics for a completed crawl.
message CrawlSummary {
  // Total documents found during crawl.
  int32 documents_found = 1;
  // Documents successfully processed.
  int32 documents_processed = 2;
  // Documents that failed processing.
  int32 documents_failed = 3;
  // Documents skipped (e.g., unchanged).
  int32 documents_skipped = 4;
  // Total bytes processed.
  int64 bytes_processed = 5;
  // Timestamp when crawl started.
  google.protobuf.Timestamp started = 6;
  // Timestamp when crawl completed.
  google.protobuf.Timestamp completed = 7;
  // Additional statistics as key-value pairs.
  map<string, string> statistics = 8;
}

// Response from ending a crawl session.
message EndCrawlSessionResponse {
  // Whether session end succeeded.
  bool success = 1;
  // Number of orphaned documents found.
  int32 orphans_found = 2;
  // Number of orphaned documents deleted (if delete_orphans was true).
  int32 orphans_deleted = 3;
  // Status or error message.
  string message = 4;
}

// ============================================
// HEARTBEAT
// ============================================

// Request to maintain an active crawl session.
message HeartbeatRequest {
  // Session identifier.
  string session_id = 1;
  // Crawl identifier.
  string crawl_id = 2;
  // Number of documents currently queued for processing.
  int32 documents_queued = 3;
  // Number of documents currently being processed.
  int32 documents_processing = 4;
  // Additional metrics as key-value pairs.
  map<string, string> metrics = 5;
}

// Response from heartbeat with optional control commands.
message HeartbeatResponse {
  // Whether the session is still valid.
  bool session_valid = 1;
  // Optional control command from server to crawler.
  ControlCommand command = 2;
  // Configuration updates to apply.
  map<string, string> config_updates = 3;
}

// Control commands sent from server to crawler.
enum ControlCommand {
  // No command specified.
  CONTROL_COMMAND_UNSPECIFIED = 0;
  // Pause the crawl temporarily.
  CONTROL_COMMAND_COMMAND_PAUSE = 1;
  // Stop the crawl completely.
  CONTROL_COMMAND_COMMAND_STOP = 2;
  // Slow down the crawl rate.
  CONTROL_COMMAND_COMMAND_THROTTLE = 3;
  // Speed up the crawl rate.
  CONTROL_COMMAND_COMMAND_SPEED_UP = 4;
}

// ============================================
// CONNECTOR REGISTRATION (Admin API)
// How connectors get registered in the system
// ============================================

// Complete connector registration information.
message ConnectorRegistration {
  // Unique connector identifier.
  string connector_id = 1;
  // Human-readable connector name.
  string connector_name = 2;
  // Connector type (e.g., "filesystem", "confluence").
  string connector_type = 3;
  // Account that owns this connector.
  string account_id = 4;
  // Generated API key for authentication.
  string api_key = 5;
  // S3 bucket for document storage.
  string s3_bucket = 6;
  // Base path prefix in S3 (e.g., "connectors/filesystem-prod/").
  string s3_base_path = 7;
  // Default metadata applied to all documents from this connector.
  map<string, string> default_metadata = 8;
  // Maximum file size allowed in bytes.
  int64 max_file_size = 9;
  // Rate limit for uploads per minute.
  int64 rate_limit_per_minute = 10;
  // Whether this connector is active.
  bool active = 11;
  // Timestamp when connector was created.
  google.protobuf.Timestamp created = 12;
  // Timestamp when connector was last updated.
  google.protobuf.Timestamp updated = 13;
}

// ============================================
// ADMIN API MESSAGES
// ============================================

// Request to register a new connector.
message RegisterConnectorRequest {
  // Human-readable connector name.
  string connector_name = 1;
  // Connector type (e.g., "filesystem", "confluence").
  string connector_type = 2;
  // Account that will own this connector.
  string account_id = 3;
  // S3 bucket for document storage.
  string s3_bucket = 4;
  // Base path prefix in S3 (e.g., "connectors/filesystem-prod/").
  string s3_base_path = 5;
  // Default metadata to apply to all documents.
  map<string, string> default_metadata = 6;
  // Maximum file size allowed in bytes.
  int64 max_file_size = 7;
  // Rate limit for uploads per minute.
  int64 rate_limit_per_minute = 8;
}

// Response from connector registration.
message RegisterConnectorResponse {
  // Whether registration succeeded.
  bool success = 1;
  // Generated unique connector identifier.
  string connector_id = 2;
  // Generated API key for authentication.
  string api_key = 3;
  // Status or error message.
  string message = 4;
}

// Request to update connector configuration.
message UpdateConnectorRequest {
  // Connector identifier to update.
  string connector_id = 1;
  // Updated connector name (optional).
  string connector_name = 2;
  // Updated S3 bucket (optional).
  string s3_bucket = 3;
  // Updated S3 base path (optional).
  string s3_base_path = 4;
  // Updated default metadata (optional).
  map<string, string> default_metadata = 5;
  // Updated max file size (optional).
  int64 max_file_size = 6;
  // Updated rate limit (optional).
  int64 rate_limit_per_minute = 7;
}

// Response from connector update.
message UpdateConnectorResponse {
  // Whether update succeeded.
  bool success = 1;
  // Status or error message.
  string message = 2;
  // Updated connector registration.
  ConnectorRegistration connector = 3;
}

// Request to get connector details.
message GetConnectorRequest {
  // Connector identifier to retrieve.
  string connector_id = 1;
}

// Response containing connector details.
message GetConnectorResponse {
  // The connector registration details.
  ConnectorRegistration connector = 1;
}

// Request to validate an API key.
message ValidateApiKeyRequest {
  // Connector identifier.
  string connector_id = 1;
  // API key to validate.
  string api_key = 2;
}

// Response from API key validation.
message ValidateApiKeyResponse {
  // Whether the API key is valid.
  bool valid = 1;
  // Validation message.
  string message = 2;
  // Full connector configuration if valid.
  ConnectorRegistration connector = 3;
}

// Request to list connectors.
message ListConnectorsRequest {
  // Optional filter by account ID.
  string account_id = 1;
  // Number of results per page.
  int32 page_size = 2;
  // Pagination token.
  string page_token = 3;
  // Whether to include inactive connectors.
  bool include_inactive = 4;
}

// Response containing connector list.
message ListConnectorsResponse {
  // List of connector registrations.
  repeated ConnectorRegistration connectors = 1;
  // Token for next page.
  string next_page_token = 2;
  // Total count of connectors.
  int32 total_count = 3;
}

// Request to enable or disable a connector.
message SetConnectorStatusRequest {
  // Connector identifier.
  string connector_id = 1;
  // Whether connector should be active.
  bool active = 2;
  // Reason for status change.
  string reason = 3;
}

// Response from status change.
message SetConnectorStatusResponse {
  // Whether status change succeeded.
  bool success = 1;
  // Status or error message.
  string message = 2;
}

// Request to delete a connector.
message DeleteConnectorRequest {
  // Connector identifier to delete.
  string connector_id = 1;
  // Whether to permanently delete (true) or soft delete (false).
  bool hard_delete = 2;
}

// Response from connector deletion.
message DeleteConnectorResponse {
  // Whether deletion succeeded.
  bool success = 1;
  // Status or error message.
  string message = 2;
  // Number of associated crawl sessions deleted.
  int32 crawl_sessions_deleted = 3;
}

// Request to rotate connector API key.
message RotateApiKeyRequest {
  // Connector identifier.
  string connector_id = 1;
  // Whether to invalidate old key immediately or allow grace period.
  bool invalidate_old_immediately = 2;
}

// Response from API key rotation.
message RotateApiKeyResponse {
  // Whether rotation succeeded.
  bool success = 1;
  // New API key.
  string new_api_key = 2;
  // When the old key will stop working.
  google.protobuf.Timestamp old_key_expires = 3;
  // Status or error message.
  string message = 4;
}

// Request to get crawl history for a connector.
message GetCrawlHistoryRequest {
  // Connector identifier.
  string connector_id = 1;
  // Maximum number of sessions to return.
  int32 limit = 2;
  // Pagination token.
  string page_token = 3;
}

// Response containing crawl history.
message GetCrawlHistoryResponse {
  // List of crawl session summaries.
  repeated CrawlSessionSummary sessions = 1;
  // Token for next page.
  string next_page_token = 2;
}

// Summary of a completed crawl session.
message CrawlSessionSummary {
  // Session identifier.
  string session_id = 1;
  // Crawl identifier.
  string crawl_id = 2;
  // Timestamp when crawl started.
  google.protobuf.Timestamp started_at = 3;
  // Timestamp when crawl completed.
  google.protobuf.Timestamp completed_at = 4;
  // Total documents found.
  int32 documents_found = 5;
  // Documents successfully processed.
  int32 documents_processed = 6;
  // Documents that failed processing.
  int32 documents_failed = 7;
  // Total bytes processed.
  int64 bytes_processed = 8;
  // Status of the crawl (e.g., "RUNNING", "COMPLETED", "FAILED").
  string status = 9;
  // Additional metadata as key-value pairs.
  map<string, string> metadata = 10;
}
