syntax = "proto3";

package ai.pipestream.repository.v1;

import "ai/pipestream/config/v1/pipeline_config_models.proto";
import "ai/pipestream/repository/v1/repository_service_data.proto";
import "google/protobuf/timestamp.proto";

option java_package = "ai.pipestream.repository.v1";
option java_multiple_files = true;

// ============================================================================
// GRAPH REPOSITORY SERVICE
// ============================================================================

// Service for managing graph nodes, edges, and topology operations
service GraphRepositoryService {
  // ========== NODE OPERATIONS ==========
  rpc CreateNode(CreateNodeRequest) returns (CreateNodeResponse);
  // Retrieves a graph node by ID.
  rpc GetNode(GetNodeRequest) returns (GetNodeResponse);
  // Updates a graph node configuration.
  rpc UpdateNode(UpdateNodeRequest) returns (UpdateNodeResponse);
  // Deletes a graph node.
  rpc DeleteNode(DeleteNodeRequest) returns (DeleteNodeResponse);
  // Lists all graph nodes with filtering.
  rpc ListNodes(ListNodesRequest) returns (ListNodesResponse);

  // ========== GRAPH OPERATIONS ==========
  rpc CreateGraph(CreateGraphRequest) returns (CreateGraphResponse);
  // Retrieves a pipeline graph by ID.
  rpc GetGraph(GetGraphRequest) returns (GetGraphResponse);
  // Updates a pipeline graph.
  rpc UpdateGraph(UpdateGraphRequest) returns (UpdateGraphResponse);
  // Deletes a pipeline graph.
  rpc DeleteGraph(DeleteGraphRequest) returns (DeleteGraphResponse);
  // Lists all pipeline graphs.
  rpc ListGraphs(ListGraphsRequest) returns (ListGraphsResponse);

  // ========== DNS-LIKE NODE RESOLUTION ==========
  rpc ResolveNode(ResolveNodeRequest) returns (ResolveNodeResponse);
  // Resolves downstream nodes following graph edges.
  rpc ResolveNextNodes(ResolveNextNodesRequest) returns (ResolveNextNodesResponse);
  // Resolves a node reference across cluster boundaries.
  rpc ResolveCrossClusterNode(ResolveCrossClusterNodeRequest) returns (ResolveCrossClusterNodeResponse);

  // ========== KAFKA TOPIC DISCOVERY ==========
  rpc FindNodesByInputTopic(FindNodesByInputTopicRequest) returns (FindNodesByInputTopicResponse);
  // Finds all nodes that produce to a specific Kafka topic.
  rpc FindNodesByOutputTopic(FindNodesByOutputTopicRequest) returns (FindNodesByOutputTopicResponse);

  // ========== LOOP DETECTION ==========
  rpc DetectLoops(DetectLoopsRequest) returns (DetectLoopsResponse);

  // ========== NETWORK TOPOLOGY ==========
  rpc GetNetworkTopology(GetNetworkTopologyRequest) returns (GetNetworkTopologyResponse);

  // ========== REAL-TIME UPDATES ==========
  rpc SubscribeToUpdates(SubscribeToUpdatesRequest) returns (stream SubscribeToUpdatesResponse);
}

// ============================================================================
// NODE REQUEST/RESPONSE MESSAGES
// ============================================================================

// Create Node request
message CreateNodeRequest {
  string cluster_id = 1;
  string name = 2;
  ai.pipestream.config.v1.NodeType node_type = 3;
  string module_id = 4;
  ai.pipestream.config.v1.JsonConfigOptions custom_config = 5;
  ai.pipestream.config.v1.TransportConfig transport = 6;
}

// Get Node request
message GetNodeRequest {
  string node_id = 1;
}

// Update Node request
message UpdateNodeRequest {
  string node_id = 1;
  string name = 2;
  ai.pipestream.config.v1.JsonConfigOptions custom_config = 3;
  ai.pipestream.config.v1.TransportConfig transport = 4;
}

// Delete Node request
message DeleteNodeRequest {
  string node_id = 1;
}

// Create Node response
message CreateNodeResponse {
  ai.pipestream.config.v1.GraphNode node = 1;
}

// Get Node response
message GetNodeResponse {
  ai.pipestream.config.v1.GraphNode node = 1;
}

// Update Node response
message UpdateNodeResponse {
  ai.pipestream.config.v1.GraphNode node = 1;
}

// Delete Node response
message DeleteNodeResponse {
  bool success = 1;
  string node_id = 2;
}

// List Nodes request
message ListNodesRequest {
  string cluster_id = 1;
  ai.pipestream.config.v1.NodeType node_type = 2; // Optional filter
  PaginationRequest pagination = 3;
}

// List Nodes response
message ListNodesResponse {
  repeated ai.pipestream.config.v1.GraphNode nodes = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

// ============================================================================
// GRAPH REQUEST/RESPONSE MESSAGES
// ============================================================================

// Create Graph request
message CreateGraphRequest {
  string cluster_id = 1;
  string name = 2;
  string description = 3;
  repeated string node_ids = 4;
  repeated ai.pipestream.config.v1.GraphEdge edges = 5;
}

// Get Graph request
message GetGraphRequest {
  string graph_id = 1;
}

// Update Graph request
message UpdateGraphRequest {
  string graph_id = 1;
  string name = 2;
  string description = 3;
  repeated string node_ids = 4;
  repeated ai.pipestream.config.v1.GraphEdge edges = 5;
}

// Delete Graph request
message DeleteGraphRequest {
  string graph_id = 1;
}

// Create Graph response
message CreateGraphResponse {
  ai.pipestream.config.v1.PipelineGraph graph = 1;
}

// Get Graph response
message GetGraphResponse {
  ai.pipestream.config.v1.PipelineGraph graph = 1;
}

// Update Graph response
message UpdateGraphResponse {
  ai.pipestream.config.v1.PipelineGraph graph = 1;
}

// Delete Graph response
message DeleteGraphResponse {
  bool success = 1;
  string graph_id = 2;
}

// List Graphs request
message ListGraphsRequest {
  string cluster_id = 1;
  PaginationRequest pagination = 2;
}

// List Graphs response
message ListGraphsResponse {
  repeated ai.pipestream.config.v1.PipelineGraph graphs = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

// ============================================================================
// DNS-LIKE RESOLUTION MESSAGES
// ============================================================================

// Resolve Node request
message ResolveNodeRequest {
  string node_id = 1;
  string cluster_id = 2; // Optional: for cross-cluster resolution
  bool use_cache = 3; // Default true
}

// Resolve Node response
message ResolveNodeResponse {
  ai.pipestream.config.v1.NodeLookupResponse node = 1;
}

// Resolve Next Nodes request
message ResolveNextNodesRequest {
  string current_node_id = 1;
  string current_cluster_id = 2;
  string condition = 3; // Optional routing condition
  bool include_cross_cluster = 4; // Default false
}

// Resolve Next Nodes response
message ResolveNextNodesResponse {
  repeated ai.pipestream.config.v1.NodeLookupResponse next_nodes = 1;
  repeated ai.pipestream.config.v1.CrossClusterNodeLookup cross_cluster_nodes = 2;
}

// Resolve Cross-Cluster Node request
message ResolveCrossClusterNodeRequest {
  string node_id = 1;
  string source_cluster_id = 2;
  string target_cluster_id = 3;
}

// Resolve Cross-Cluster Node response
message ResolveCrossClusterNodeResponse {
  ai.pipestream.config.v1.CrossClusterNodeLookup node = 1;
}

// ============================================================================
// KAFKA TOPIC DISCOVERY MESSAGES
// ============================================================================

// Find Nodes by Input Topic request
message FindNodesByInputTopicRequest {
  string topic_name = 1;
  string cluster_id = 2; // Optional: search specific cluster
}

// Find Nodes by Input Topic response
message FindNodesByInputTopicResponse {
  repeated ai.pipestream.config.v1.GraphNode nodes = 1;
}

// Find Nodes by Output Topic request
message FindNodesByOutputTopicRequest {
  string topic_name = 1;
  string cluster_id = 2; // Optional: search specific cluster
}

// Find Nodes by Output Topic response
message FindNodesByOutputTopicResponse {
  repeated ai.pipestream.config.v1.GraphNode nodes = 1;
}

// ============================================================================
// LOOP DETECTION MESSAGES
// ============================================================================

// Detect Loops request
message DetectLoopsRequest {
  string starting_node_id = 1;
  string cluster_id = 2;
  int32 max_depth = 3; // Prevent infinite traversal
}

// Detect Loops response
message DetectLoopsResponse {
  bool has_loops = 1;
  repeated LoopPath detected_loops = 2;
}

// Loop Path definition
message LoopPath {
  repeated string node_ids = 1;
  repeated string cluster_ids = 2; // Parallel to node_ids
}

// ============================================================================
// NETWORK TOPOLOGY MESSAGES
// ============================================================================

// Get Network Topology request
message GetNetworkTopologyRequest {
  string cluster_id = 1;
  bool include_cross_cluster = 2;
  int32 max_depth = 3; // For large networks
}

// Get Network Topology response
message GetNetworkTopologyResponse {
  ai.pipestream.config.v1.NetworkTopology topology = 1;
}

// ============================================================================
// REAL-TIME UPDATES MESSAGES
// ============================================================================

// Subscribe to Updates request
message SubscribeToUpdatesRequest {
  string cluster_id = 1;
  repeated ai.pipestream.config.v1.UpdateType update_types = 2; // Filter by update types
}

// Subscribe to Updates response (streaming)
message SubscribeToUpdatesResponse {
  ai.pipestream.config.v1.UpdateType update_type = 1;
  google.protobuf.Timestamp timestamp = 2;
  oneof updated_entity {
    ai.pipestream.config.v1.GraphNode node = 3;
    ai.pipestream.config.v1.PipelineGraph graph = 4;
    ai.pipestream.config.v1.GraphEdge edge = 5;
  }
}
